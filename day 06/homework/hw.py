# 1) Sololearn:

# 2) კომენტარებით ახსენით რა არის sequences, iteration და selection. მოიყვანეთ მათი მაგალითები

# 1. Sequences (სერიები):

# სერია არის პროგრამირების სტრუქტურა, სადაც ინსტრუქციები შესრულდება თანმიმდევრობით, ერთის შემდეგ მეორეზე. ამ დროს არ არის რაიმე ფილიალი ან გაჭრის ეტაპი — ყოველი ნაბიჯი გარკვეული რიგით შესრულდება.

# მაგალითი:

# python
# Copy
# Edit
print("მივესალმები")
print("როგორ ხარ?")
print("გადავიტანე")
# ამ მაგალითში პირველი print ბრძანება გამოიძახება პირველი, შემდეგ მეორე და მესამე შესაბამისად.

# 2. Iteration (ციკლი):

# Iteration არის პროცესი, როცა რაღაც მოქმედება გეომეტრიული რაოდენობით იმეორდება (ან ლოგიკური პირობების დაკმაყოფილებამდე). უფრო ხშირად ციკლების სახით ვხვდებით, როდესაც მოთხოვნა არსებობს რაიმე რაოდენობის ნიმუშების გადამუშავებისთვის.

# მაგალითი:

# python
# Copy
# Edit
for i in range(1, 5):
    print(i)
# ამ პროგრამაში, ციკლი გამოიძახებს print ბრძანებას 4-ჯერ, რადგან range(1, 5) ქმნის რიცხვების სერიას 1-დან 4-მდე.

# 3. Selection (ორბიტა):

# Selection, ანუ არჩევანი, არის ცვლის სტრუქტურა, რომლის საშუალებითაც ვამოწმებთ რაღაც პირობებს და, იმაზე დამოკიდებულებით, თუ არის თუ არა პირობა ჭეშმარიტი, ვაკეთებთ განსხვავებულ მოქმედებებს.

# მაგალითი:

# python
# Copy
# Edit
age = 18

if age >= 18:
    print("შეგიძლია მოზრდილის უფლება")
else:
    print("შეიძლება არ გქონდეს სრულუფლებიანი სტატუსი")
# ამ შემთხვევაში, თუ age მნიშვნელობა 18-ზე მეტია, პროგრამა შეასრულებს პირველ დავალებას, წინააღმდეგ შემთხვევაში — მეორე.

# შეჯამება:

# Sequece: ინსტრუქციები შესრულდება ერთმანეთის შემდეგ.

# Iteration: გეომეტრიულად ან ლოგიკურად განმეორებითი მოქმედებები.

# Selection: შემთხვევითი არჩევანი, თუ რას შევასრულებთ პირობის მიხედვით.

# შესაძლოა, ყოველივე ეს თქვენს კოდში ხშირად დაგჭირდეთ!


# 3) კომენტარებით ახსენით, რა არის ალგორითმი და ჩამოთვალეთ რა გზები არსებობს მის წარმოსადგენად.

# 3. ალგორითმი:

# ალგორითმი არის გარკვეული მოქმედებების სერია, რომელიც მოცემულ პრობლემას ან ამოცანას ასრულებს კონკრეტული წესების და ნაბიჯების მიხედვით. ალგორითმი უნდა იყოს ზუსტი, განსაზღვრული და ხელმისაწვდომი გამოსაყენებლად. იგი წარმოდგენილია ისეთ ფორმატში, რომლის მიხედვითაც კომპიუტერი ან სხვა გამოთვლითი მოწყობილობა შეძლებს მისი განხორციელებას.

# მნიშვნელოვანი მახასიათებლები:

# ზუსტობა – ყველა ნაბიჯი და წესები უნდა იყოს მკაფიო და ცხადი.

# შემქმნელობა – ალგორითმი უნდა იყოს შესაძლებელი სხვადასხვა მონაცემების შესატყვისად.

# დასრულებულობა – ალგორითმი უნდა დაასრულოს თავის მუშაობას სუსტი ან გადაჭრის შემთხვევაში.

# ეფექტურობა – ალგორითმი უნდა იყოს საკმარისად სწრაფი და ეფექტური მოცემული პრობლემისთვის.

# ალგორითმის წარმოსახვის გზები:

# პსევდოკოდი (Pseudocode):
# პსევდოკოდი არის ალგორითმის აღწერა, რომელიც გამოიყენება ადამიანის წაკითხვისთვის. ის ბუნებრივ ენაზეა დაწერილი, თუმცა გვხვდება ისეთ პროგრამული ენების ტერმინები, რომლებიც ადვილად გასაგებია. პსევდოკოდი არ ექვემდებარება სინტაქსური მოთხოვნებს, მაგრამ სრულყოფილი ალგორითმის თეორიული ფორმაა.

# მაგალითი:

# plaintext
# Copy
# Edit
# თუ რიცხვი არის დადებითი:
#     დაბეჭდეთ "დადებითი"
# თუ არა:
#     დაბეჭდეთ "უარყოფითი"
# ფლოგრაფი (Flowchart):
# ფლო გრაფი (ან გრაფიკის ნავიგაცია) ვიზუალური საშუალებაა, რომელსაც იყენებენ ალგორითმის გადმოსაცემად. აქ გამოიყენება სხვადასხვა გრაფიკული სიმბოლოები, რომლებიც გარკვეული ტიპის მოქმედებებს ან პირობებს აღნიშნავენ, ხოლო ხაზები და ისრები აჩვენებენ ამ მოქმედებების თანმიმდევრობას.

# მაგალითი:

# css
# Copy
# Edit
# [დაწყება]
#     ↓
# [რიცხვის შემოწმება]
#     ↓
# [დაბეჭდეთ "დადებითი"] ---> [დასრულება]
#     ↑
# [დაბეჭდეთ "უარყოფითი"]
#     ↓
# [დასრულება]
# კოდირება (Programming Code):
# ალგორითმი შეიძლება იყოს დაწერილი პროგრამირების ენაზე. ეს არის ფორმალური, სრულად აღჭურვილი ალგორითმი, რომელსაც კომპიუტერი შეიძლება ასრულებდეს.

# მაგალითი (Python):

# python
# Copy
# Edit
number = int(input("შეიყვანე რიცხვი: "))
if number > 0:
    print("დადებითი")
else:
    print("უარყოფითი")
# ალგორითმის სხვა წარმოშობის გზები:

# განმეორებითი სტრუქტურები (Recursion):
# ეს არის ალგორითმი, რომელიც თავის თავზე ეყრდნობა. იგი ერთი ნაბიჯით იყენებს თავის უფრო მარტივ ან მინიმუმ მასთან დაკავშირებულ ფორმას.

# მაგალითი (ფიბონაჩის რიცხვი):

# python
# Copy
# Edit
def fibonacci(n):
    if n <= 1:
        return n
    else:
#         return fibonacci(n-1) + fibonacci(n-2)
# ჩუმი მეხსიერება (Automated Reasoning):
# არსებობს ალგორითმების დიზაინის სისტემები, რომლებიც მუშაობენ ლოგიკურ დავალებებზე, მათ შორის დასკვნები (automated reasoning). ეს შეიძლება იყოს ფორმულიირებული გრაფიკების ან ცხრილების სერიაში.

# შეჯამება:

# ალგორითმი – არის ზუსტი, განმსაზღვრელი ნაბიჯების სერია.

# ალგორითმის წერის ფორმები:

# პსევდოკოდი – დაწერილი მარტივი ენაზე.

# ფლოგრაფი – ვიზუალური გრაფიკის ფორმატი.

# კოდირება – დაწერილი პროგრამირების ენაზე.

# განმეორებითი სტრუქტურები – რიკურსია.

# ჩუმი მეხსიერება – ლოგიკური ანალიზი.

# ალგორითმის სწორად გადმოცემა და გააზრება გადამწყვეტია სწორი და ეფექტური პროგრამების შექმნისთვის!


# 4) შეეცადეთ თქვენით მიხვდეთ, თუ რა პასუხს გამოიტანს შემდეგი კოდი:

# print(True or False and False or True and False or False and False or False and True and False or True)
# print(5 > 10 or 7 * 7 / 7 == 7 and False or True and "1234" != "1234" and 7 + 3 * 3 + 1 == 15 and True and True or 100 > 100 or True)

# პირველ რიგში დაუყევით and ლოგიკურ ოპერატორებს, შემდეგ კი დარჩენილ or ოპერატორებს

# 5) მომხმარებელს შემოატანინეთ რიცხვი და თუ ის არის ლუწი და არის 10-ზე მეტი, ან ტოლია 7-ის, დაბეჭდეთ True

# 6) ივარჯიშეთ შემდეგ ფუნქციებზე: int, str, float, bool. თითოეულზე გააკეთეთ 3-3 მაგალითი

# 7) მომხმარებელს შემოატანინეთ წელი და შეამოწმეთ, თუ ის არის ნაკიანი დაბეჭდეთ "This is leap year".(ნაკიანი წელიწადი იყოფა 4-ზე და არ იყოფა 100-ზე ან იყოფა 400-ზე)